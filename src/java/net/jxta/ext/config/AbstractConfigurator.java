/*
 *  Copyright (c) 2001 Sun Microsystems, Inc.  All rights
 *  reserved.
 *
 *  Redistribution and use in source and binary forms, with or withouta
 *  modification, are permitted provided that the following conditions
 *  are met:
 *
 *  1. Redistributions of source code must retain the above copyright
 *  notice, this list of conditions and the following disclaimer.
 *
 *  2. Redistributions in binary form must reproduce the above copyright
 *  notice, this list of conditions and the following discalimer in
 *  the documentation and/or other materials provided with the
 *  distribution.
 *
 *  3. The end-user documentation included with the redistribution,
 *  if any, must include the following acknowledgment:
 *  "This product includes software developed by the
 *  Sun Microsystems, Inc. for Project JXTA."dres
 *  Alternately, this acknowledgment may appear in the software itself,
 *  if and wherever such third-party acknowledgments normally appear.
 *
 *  4. The names "Sun", "Sun Microsystems, Inc.", "JXTA" and "Project JXTA"
 *  must not be used to endorse or promote products derived from this
 *  software without prior written permission. For written
 *  permission, please contact Project JXTA at http://www.jxta.org.
 *
 *  5. Products derived from this software may not be called "JXTA",
 *  nor may "JXTA" appear in their name, without prior written
 *  permission of Sun.
 *
 *  THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 *  WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 *  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 *  DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 *  ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 *  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 *  USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 *  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 *  OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 *  SUCH DAMAGE.
 *  ====================================================================
 *
 *  This software consists of voluntary contributions made by many
 *  individuals on behalf of Project JXTA.  For more
 *  information on Project JXTA, please see
 *  <http://www.jxta.org/>.
 *
 *  This license is based on the BSD license adopted by the Apache Foundation.
 *
 *  $Id: AbstractConfigurator.java,v 1.1 2007/01/16 11:01:36 thomas Exp $
 */

package net.jxta.ext.config;

import net.jxta.exception.ConfiguratorException;
import net.jxta.protocol.ConfigParams;

import net.jxta.peergroup.PeerGroupFactory;
import net.jxta.peergroup.PeerGroupID;
import net.jxta.impl.peergroup.NullConfigurator;
import net.jxta.impl.peergroup.PlatformConfigurator;
import net.jxta.impl.protocol.PlatformConfig;

import java.io.BufferedOutputStream;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.InputStream;
import java.io.IOException;
import java.net.URI;
import java.net.URISyntaxException;

import java.util.Collections;
import java.util.Iterator;
import java.util.HashMap;
import java.util.Map;
import java.util.Properties;

import org.apache.log4j.Level;
import org.apache.log4j.Logger;


/**
 * An abstract {@link net.jxta.impl.peergroup.PlatformConfigurator} implementation
 * that manages {@link net.jxta.impl.protocol.PlatformConfig} lifecyle events
 * that include configuration creation and update which typically occur prior to
 * {@code Platform} startup although dynamic {@link net.jxta.impl.peergroup.Platform} configuration
 * management is an active discussion at this time.
 *
 * The default backing configurator is {@link net.jxta.ext.config.Configurator}
 * that is overridable via a number of constructor options.
 *
 * @author  james todd [gonzo at jxta dot org]
 */

public abstract class AbstractConfigurator
implements PlatformConfigurator {
    
    /**
     * {@link net.jxta.ext.config.Profile} key {@value}
     */
    
    public static final String PROFILE_KEY = Env.PROFILE;
    
    /**
     * {@link net.jxta.impl.peergroup.Platform} config.properties key {@value}
     */
    
    public static final String CONFIG_PROPERTIES_KEY = Env.CONFIG_PROPERTIES;
    
    /**
     * {@link net.jxta.impl.peergroup.Platform} jxta.properties key {@value}
     */
    
    public static final String JXTA_PROPERTIES_KEY = "jxta.properties";
    
    private static final String DEFAULT_PROFILE =
        "/net/jxta/ext/config/resources/edge.xml";
    private static final String DEFAULT_JXTA_PROPERTIES = "/jxta.properties";
    private static final String CONFIG_PROPERTIES_COMMENT = "generated by " +
        AbstractConfigurator.class.getName();
    private static final Logger LOG =
        Logger.getLogger(AbstractConfigurator.class.getName());
    
    private Configurator configurator;
    private Map resources = new HashMap();
    private URI home = null;
    private Profile profile = null;
    private PlatformConfig platformConfig = null;
    private boolean reconfigure = false;
    
    /**
     * Registers a delegate {@link net.jxta.ext.config.Configurator} class with the {@link net.jxta.impl.peergroup.Platform}
     * that will manage configuration resources.
     *
     * @deprecated  will be removed
     * @param       configurator class
     */
    
    public static void register(Class configurator) {
        Configurator.setConfigurator(configurator);
    }
    
    /**
     * Default constructor.
     *
     * The default {@code JXTA_HOME} will be {@code System.getProperty("user.home", ".jxta/");}
     * and the default {@link net.jxta.ext.config.Profile} will be {@link net.jxta.ext.config.Profile#DEFAULT}.
     */
    
    public AbstractConfigurator() {
    }
    
    /**
     * Constructor whereby one can specify a non-default {@code JXTA_HOME}
     * value as a {@link java.net.URI}, typically of scheme {@code file}.
     *
     * @param   home the desired {@code JXTA_HOME} destination.
     */
    
    public AbstractConfigurator(URI home) {
        this(home, null);
    }
    
    /**
     * Constructor whereby one can specify a non-default {@link net.jxta.ext.config.Profile}.
     *
     * @param   profile the desired {@link net.jxta.ext.config.Profile}.
     */
    
    public AbstractConfigurator(Profile profile) {
        this(null, profile);
    }
    
    /**
     * Constructor whereby one can specify a non-default {@code JXTA_HOME},
     * typically with a scheme of type {@code file}, and a non-default
     * {@link net.jxta.ext.config.Profile}.
     *
     * @param   home the desired {@code JXTA_HOME} destination.
     * @param   profile the desired {@link net.jxta.ext.config.Profile}.
     */
    
    public AbstractConfigurator(URI home, Profile profile) {
        this.home = home;
        this.profile = profile;
         
        // register the default resources
        this.resources.put(PROFILE_KEY, DEFAULT_PROFILE);
        this.resources.put(JXTA_PROPERTIES_KEY, DEFAULT_JXTA_PROPERTIES);

        // turn of the default Platform Configurator
        Configurator.setConfigurator(NullConfigurator.class);
    }
        
    /**
     * Constructor which overrides the backing {@link net.jxta.ext.config.Configurator}.
     *
     * @param   configurator the delegate {@link net.jxta.ext.config.Configurator}.
     */
    
    public AbstractConfigurator(Configurator configurator) { 
        this.configurator = configurator;

        // register the default resources
        this.resources.put(PROFILE_KEY, DEFAULT_PROFILE);
        this.resources.put(JXTA_PROPERTIES_KEY, DEFAULT_JXTA_PROPERTIES);

        // turn of the default Platform Configurator
        Configurator.setConfigurator(NullConfigurator.class);
    }
    
    /**
     * Application callback invoked when constructing a new {@link net.jxta.impl.protocol.PlatformConfig}.
     *
     * @param       configurator    controlling {@link net.jxta.ext.config.Configurator}
     * @return                      generated {@link net.jxta.impl.protocol.PlatformConfig}
     * @exception   ConfiguratorException   for invalid {@link net.jxta.ext.config.Configurator} operations
     */
    
    public abstract PlatformConfig createPlatformConfig(Configurator configurator)
    throws ConfiguratorException;
    
    /**
     * Application callback invoked providing a chance to update a previously
     * generated {@link net.jxta.impl.protocol.PlatformConfig}.
     *
     * @param       configurator    controlling {@link net.jxta.ext.config.Configurator}
     * @return                      generated {@link net.jxta.impl.protocol.PlatformConfig}
     * @exception   ConfiguratorException   for invalid {@link net.jxta.ext.config.Configurator} operations
     */
    
    public PlatformConfig updatePlatformConfig(Configurator configurator)
    throws ConfiguratorException {
        if (configurator == null) {
            throw new ConfiguratorException("null configurator");
        }
        
        return configurator.getPlatformConfig();
    }
    
    /**
     * Method which triggers the construction and/or update of the {@code Platform}
     * systems dependencies (eg {@link net.jxta.impl.protocol.PlatformConfig},
     * {@code config.properties}, etc.).
     *
     * @return      representative {@code PlatformConfig}
     * @throws     ConfiguratorException    {@link net.jxta.exception.ConfiguratorException}
     *                                      chained list of configuration errors     */
    
    public PlatformConfig configure()
    throws ConfiguratorException {
        return getPlatformConfig();
    }
    
    /**
     * Accessor to the resource keys.
     *
     * @return      resource key {@link java.util.Iterator}.
     */
    
    public Iterator getResourceKeys() {
        return this.resources != null ?
            Collections.EMPTY_MAP.keySet().iterator() :
            this.resources.keySet().iterator();
    }

    /**
     * Accessor to a named resource.
     *
     * @param   key resource key
     * @return      resource value
     */
    
    public String getResource(String key) {
        return this.resources != null ?
            (String)this.resources.get(key) : null;
        }
        
    /**
     * Adds a resource key-value pair.
     *
     * @param   key     resource key
     * @param   value   resource value
     * @return          previously existing resource value for the provided key
     */
    
    public String addResource(String key, String value) {
        if (key == null || value == null) {
            throw new IllegalArgumentException("invalid key|value");
        }
        
        return (String)this.resources.put(key, value);
    }
    
    /**
     * Adds a series of resource key-value pairs.
     *
     * @param   resources   resources
     */
    
    public void addResources(Map resources) {
        if (resources == null) {
            throw new IllegalArgumentException("invalid resources");
        }
        
        this.resources.putAll(resources);
    }
    
    /**
     * Removes a named resource.
     *
     * @param   key resource name
     * @return      removed resource value
     */
    
    public String removeResource(String key) {
        return this.resources != null ?
            (String)this.resources.remove(key) : null;
    }
    
    /**
     * Removes all resources.
     *
     * @return      previously existing resources
     */
    
    public Map clearResources() {
        Map r = new HashMap(resources);
        
        this.resources.clear();
        
        return r;
    }
        
    /**
     * Accessor to the configured {@code JXTA_HOME}
     *
     * @deprecated      in favor of {@link net.jxta.ext.config.AbstractConfigurator#getJxtaHome()}
     * @return          {@code JXTA_HOME} location
     */
    
    public URI getJXTAHome() {
        return getJxtaHome();
    }
    
    /**
     * Accessor to the configured {@code JXTA_HOME}
     *
     * @return          {@code JXTA_HOME} location
     */
    
    public URI getJxtaHome() {
        return this.configurator != null ?
            this.configurator.getJxtaHome() : this.home;
    }
    
    /**
     * {@inheritDoc}
     */
    
    public PlatformConfig getPlatformConfig()
    throws ConfiguratorException {
        URI jh = getJxtaHome();
        // xxx: assume File based JXTA_HOME for the moment
        File f = null;
        
        try {
            f = Conversion.toFile(jh);
        } catch (ConversionException ce) {
            if (LOG.isEnabledFor(Level.ERROR)) {
                LOG.error("can't convert uri to file: " + jh, ce);
            }
        }
        
        manageResources(f);
        
        if (this.configurator == null) {
            this.configurator = new Configurator(this.home, this.profile);
            
            if (this.platformConfig != null) {
                this.configurator.setPlatformConfig(this.platformConfig);
            }
            
            this.configurator.setReconfigure(this.reconfigure);
        }
        
        File cf = new File(f, Env.PLATFORM_CONFIG);
        PlatformConfig pc = null;
        
        try {
            pc = this.configurator.load(cf);
        } catch (ConfiguratorException ce) {
            if (LOG.isEnabledFor(Level.INFO)) {
                LOG.info("invalid platform config: " +
                (cf != null ? cf.getAbsoluteFile() : null), ce);
            }
        }
        
        if (pc == null) {
            try {
                pc = createPlatformConfig(this.configurator);
            } catch (ConfiguratorException ce) {
                if (LOG.isEnabledFor(Level.INFO)) {
                    LOG.info("invalid PlatformConfig creation", ce);
                }
                
                throw ce;
            }
        }
        
        this.configurator.setPlatformConfig(pc);
        
        try {
            pc = updatePlatformConfig(this.configurator);
        } catch (ConfiguratorException ce) {
            if (LOG.isEnabledFor(Level.INFO)) {
                LOG.info("invalid PlatformConfig update", ce);
            }
            
            throw ce;
        }
        
        try {
            this.configurator.save(cf);
        } catch (ConfiguratorException ce) {
            if (LOG.isEnabledFor(Level.INFO)) {
                LOG.info("unable to persist PlatformConfig: " +
                    (cf != null ? cf.toString() : null), ce);
            }
            
            throw ce;
        }
        
        return pc;
    }
    
    /**
     * {@inheritDoc}
     */
    
    public void setPlatformConfig(PlatformConfig config) {
        if (this.configurator != null) {
            this.configurator.setPlatformConfig(config);
        } else {
            this.platformConfig = config;
        }
    }
    
    /**
     * {@inheritDoc}
     */
    
    public ConfigParams getConfigParams()
    throws ConfiguratorException {
        return this.configurator != null ?
            this.configurator.getConfigParams() :
            (ConfigParams)this.platformConfig;
    }
    
    /**
     * {@inheritDoc}
     */
    
    public void setConfigParams(ConfigParams cp) {
        setPlatformConfig((PlatformConfig)cp);
    }
    
    /**
     * {@inheritDoc}
     */
    
    public void setReconfigure(boolean reconfigure) {
        if (this.configurator != null) {
            this.configurator.setReconfigure(reconfigure);
        } else {
            this.reconfigure = reconfigure;
        }
    }
    
    /**
     * {@inheritDoc}
     */
    
    public ConfigParams load()
    throws ConfiguratorException {
        ConfigParams cp = null;
        
        if (this.configurator != null) {
            cp = this.configurator.load();
        } else {
            throw new IllegalStateException("null configurator");
        }
        
        return cp;
    }
    
    /**
     * {@inheritDoc}
     */
    public PlatformConfig load(File pc)
    throws ConfiguratorException {
        PlatformConfig p = null;
        
        if (this.configurator != null) {
            p = this.configurator.load(pc);
        } else {
            throw new IllegalStateException("null configurator");
        }
        
        return p;
    }
    
    /**
     * {@inheritDoc}
     */
    public boolean isReconfigure() {
        return this.configurator != null ?
            this.configurator.isReconfigure() : this.reconfigure;
    }
    
    /**
     * {@inheritDoc}
     */
    public boolean save()
    throws ConfiguratorException {
        boolean s = false;
        
        if (this.configurator != null) {
            s = this.configurator.save();
        } else {
            throw new IllegalStateException("null configurator");
        }
        
        return s;
    }
    
    /**
     * {@inheritDoc}
     */
    public boolean save(File f)
    throws ConfiguratorException {
        boolean s = false;
        
        if (this.configurator != null) {
            s = this.configurator.save(f);
        } else {
            throw new IllegalStateException("null configurator");
        }
        
        return s;
    }
    
    private void manageResources(File f) {       
        for (Iterator r = getResourceKeys(); r.hasNext(); ) {
            String key = (String)r.next();
            String value = (String)getResource(key);
            File fr = new File(f, key);
            
            if (! fr.exists()) {
                InputStream is = getClass().getResourceAsStream(value);
                
                if (is != null) {
                    BufferedOutputStream bos = null;
                    
                    try {
                        fr.createNewFile();
                        
                        bos = new BufferedOutputStream(new FileOutputStream(fr));
                        
                        int c = -1;
                        
                        while ((c = is.read()) > -1) {
                            bos.write(c);
                        }
                        
                        bos.flush();
                    } catch (IOException ioe) {
                        if (LOG.isEnabledFor(Level.ERROR)) {
                            LOG.error("can't persist resource: " + fr.getName(),
                                ioe);
                        }
                    } finally {
                        if (is != null) {
                            try {
                                is.close();
                            } catch (IOException ioe) {}
                        }
                        
                        if (bos != null) {
                            try {
                                bos.close();
                            } catch (IOException ioe) {}
                        }
                    }
                }
            }
        }
        
        manageConfigProperties(f);
    }
    
    private void manageConfigProperties(File f) {
        File cf = new File(f, CONFIG_PROPERTIES_KEY);
        
        if (! cf.exists()) {
            String nid = null;
            String nnm = null;
            String nds = null;
            
            if (this.configurator != null) {
                nid = this.configurator.getInfrastructurePeerGroupId().toURI().toString();
                nnm = this.configurator.getInfrastructurePeerGroupName();
                nds = this.configurator.getInfrastructurePeerGroupDescription();
            } else if (this.profile != null) {
                Resource r = this.profile.getProfile();
                
                nid = r.get(Profile.Key.NETWORK_ID);
                nnm = r.get(Profile.Key.NETWORK_NAME);
                nds = r.get(Profile.Key.NETWORK_DESCRIPTION);
                
                boolean isValid = false;
                
                try {
                    PeerGroupID.create(new URI(nid));
                    
                    isValid = true;
                } catch (URISyntaxException use) {
                    if (LOG.isEnabledFor(Level.DEBUG)) {
                        LOG.debug("invalid " + CONFIG_PROPERTIES_KEY + " " +
                            Env.NETWORK_ID_KEY + ": " + nid, use);
                    }
                }
                
                if (! isValid) {
                    nid = null;
                }
            }
            
            nid = nid != null ? nid.trim() : null;
            nnm = nnm != null ? nnm.trim() : null;
            nds = nds != null ? nds.trim() : null;
 
            if (nid != null) {
                Properties p = new Properties();

                p.put(Env.NETWORK_ID_KEY, nid);

                if (nnm != null) {
                    p.put(Env.NETWORK_NAME_KEY, nnm);
                }

                if (nds != null) {
                    p.put(Env.NETWORK_DESCRIPTION_KEY, nds);
                }

                try {
                    p.store(new FileOutputStream(cf), CONFIG_PROPERTIES_COMMENT);
                } catch (FileNotFoundException fnfe) {
                    if (LOG.isEnabledFor(Level.ERROR)) {
                        LOG.error("can't write config.properties: " + cf, fnfe);
                    }
                } catch (IOException ioe) {
                    if (LOG.isEnabledFor(Level.ERROR)) {
                        LOG.error("can't write config.properties: " + cf, ioe);
                    }
                }
            }
         }
     }
}
