/*
 * Copyright (c) 2001 Sun Microsystems, Inc.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution,
 *    if any, must include the following acknowledgment:
 *       "This product includes software developed by the
 *       Sun Microsystems, Inc. for Project JXTA."
 *    Alternately, this acknowledgment may appear in the software itself,
 *    if and wherever such third-party acknowledgments normally appear.
 *
 * 4. The names "Sun", "Sun Microsystems, Inc.", "JXTA" and "Project JXTA" must
 *    not be used to endorse or promote products derived from this
 *    software without prior written permission. For written
 *    permission, please contact Project JXTA at http://www.jxta.org.
 *
 * 5. Products derived from this software may not be called "JXTA",
 *    nor may "JXTA" appear in their name, without prior written
 *    permission of Sun.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL SUN MICROSYSTEMS OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of Project JXTA.  For more
 * information on Project JXTA, please see
 * <http://www.jxta.org/>.
 *
 * This license is based on the BSD license adopted by the Apache Foundation.
 *
 * $Id: PlatformConfig.java,v 1.1 2007/01/16 11:01:40 thomas Exp $
 */

package net.jxta.impl.protocol;

import java.io.ByteArrayInputStream;
import java.net.URI;
import java.security.PrivateKey;
import java.security.cert.Certificate;
import java.security.cert.CertificateFactory;
import java.util.Enumeration;
import java.util.Map;
import java.util.Iterator;

import java.net.URISyntaxException;

import org.apache.log4j.Level;
import org.apache.log4j.Logger;

import net.jxta.document.Advertisement;
import net.jxta.document.AdvertisementFactory;
import net.jxta.document.Attributable;
import net.jxta.document.Attribute;
import net.jxta.document.Document;
import net.jxta.document.Element;
import net.jxta.document.MimeMediaType;
import net.jxta.document.StructuredDocument;
import net.jxta.document.StructuredDocumentFactory;
import net.jxta.document.StructuredDocumentUtils;
import net.jxta.document.StructuredTextDocument;
import net.jxta.document.TextElement;
import net.jxta.document.XMLElement;
import net.jxta.document.AdvertisementFactory.Instantiator;
import net.jxta.id.ID;
import net.jxta.id.IDFactory;
import net.jxta.peer.PeerID;
import net.jxta.platform.ModuleClassID;
import net.jxta.protocol.ConfigParams;

/**
 * This type of advertisement is generated by configuration and serves to
 * pass to all services their optional user-driven configuration. Some of which
 * may be published as part of the above process. A PlatformConfig is not itself
 * published.
 **/
public final class PlatformConfig extends ConfigParams {
    
    private static final String advType =  "jxta:PlatformConfig";
    
    /**
     *  Instantiator for PlatformConfig
     **/
    public static class Instantiator implements AdvertisementFactory.Instantiator {
        
        /**
         * Returns the identifying type of this Advertisement.
         *
         * @return String the type of advertisement
         *
         * @since JXTA 1.0
         **/
        public String getAdvertisementType( ) {
            return advType;
        }
        
        /**
         * Constructs an instance of <CODE>Advertisement</CODE> matching the type
         * specified by the <CODE>advertisementType</CODE> parameter.
         *
         * @since JXTA 1.0
         *
         * @return The instance of <CODE>Advertisement</CODE> or null if it
         * could not be created.
         *
         **/
        public Advertisement newInstance( ) {
            return new PlatformConfig();
        }
        
        /**
         * Constructs an instance of <CODE>Advertisement</CODE> matching the type
         * specified by the <CODE>advertisementType</CODE> parameter.
         *
         * @since JXTA 1.0
         *
         * @param root Specifies a portion of a StructuredDocument which will be
         * converted into an Advertisement.
         * @return The instance of <CODE>Advertisement</CODE> or null if it
         * could not be created.
         *
         **/
        public Advertisement newInstance(Element root) {
            return new PlatformConfig( root );
        }
    };
    
    private static final Logger LOG = Logger.getLogger(PlatformConfig.class.getName());
    
    private static final String DEBUG_TAG = "Dbg";
    private static final String DEBUG_TAG_DEFAULT = "user default";
    private static final String PID_TAG = "PID";
    private static final String NAME_TAG = "Name";
    private static final String DESC_TAG = "Desc";
    private static final String SVC_TAG = "Svc";
    private static final String MCID_TAG = "MCID";
    private static final String PARAM_TAG = "Parm";
    private static final String [] fields = { NAME_TAG, PID_TAG };
    
    
    /**
     * The id of this peer.
     **/
    private PeerID pid = null;
    
    /**
     * The name of this peer. Not gaurnteed to be unique in any way. May be empty or
     * null.
     **/
    private String name = null;
    
    /**
     * Descriptive meta-data about this peer.
     */
    private Element description = null;
    
    private String debugLevel = DEBUG_TAG_DEFAULT;
    
    /**
     *  Use the Instantiator through the factory
     **/
    PlatformConfig() {
    }
    
    /**
     *  Use the Instantiator through the factory
     **/
    PlatformConfig( Element root ) {
        if( !XMLElement.class.isInstance( root ) )
            throw new IllegalArgumentException( getClass().getName() + " only supports XLMElement" );
        
        XMLElement doc = (XMLElement) root;
        
        String doctype = doc.getName();
        
        String typedoctype = "";
        Attribute itsType = doc.getAttribute( "type" );
        if( null != itsType )
            typedoctype = itsType.getValue();
        
        if( !doctype.equals(getAdvertisementType()) && !getAdvertisementType().equals(typedoctype) ) {
            throw new IllegalArgumentException( "Could not construct : "
            + getClass().getName() + "from doc containing a " + doc.getName() );
        }
        
        Enumeration elements = doc.getChildren();
        
        while (elements.hasMoreElements()) {
            Element elem = (Element) elements.nextElement();
            
            if( !handleElement( elem ) ) {
                if ( LOG.isEnabledFor(Level.DEBUG) )
                    LOG.debug( "Unhandled Element: " + elem.toString() );
            }
        }
        
        // Sanity Check!!!
        
    }
    
    /**
     * Make a safe clone of this PlatformConfig.
     *
     * @return Object an object of class PlatformConfig that is a deep-enough
     * copy of this one.
     */
    public Object clone() {
        
        PlatformConfig result = new PlatformConfig();
        
        result.setPeerID( getPeerID() );
        result.setName( getName() );
        result.setDesc( getDesc() );
        result.setDebugLevel( getDebugLevel() );
        
        Iterator eachEntry = getServiceParamsEntrySet().iterator();
        
        while( eachEntry.hasNext() ) {
            Map.Entry anEntry = (Map.Entry) eachEntry.next();
            
            result.putServiceParam( (ID) anEntry.getKey(), (Element) anEntry.getValue() );
        }
        
        return result;
    }
    
    /**
     * returns the advertisement type
     *
     * @return string type
     */
    public static String getAdvertisementType() {
        return advType;
    }
    
    /**
     * {@inheritDoc}
     **/
    public String getAdvType() {
        return getAdvertisementType();
    }
    
    /**
     * returns the name of the peer.
     * @return String name of the peer.
     *
     * @since JXTA 1.0
     */
    
    public String getName() {
        return name;
    }
    
    /**
     * sets the name of the peer.
     * @param name name of the peer.
     *
     * @since JXTA 1.0
     */
    
    public void setName(String name) {
        this.name = name;
    }
    
    /**
     * Returns the id of the peer.
     * @return PeerID the peer id
     *
     * @since JXTA 1.0
     */
    
    public PeerID getPeerID() {
        return pid;
    }
    
    /** Sets the id of the peer.
     * @since JXTA 1.0
     * @param pid the id of this peer.
     */
    
    public void setPeerID(PeerID pid) {
        this.pid = pid;
    }
    
    /**
     * Returns a unique ID for that peer X group intersection. This is for indexing
     * purposes only.
     *
     */
    
    public ID getID() {
        
        return pid;
    }
    
    /**
     * returns the description
     *
     * @return String the description
     */
    public String getDescription() {
        return (null == description) ? (String) null : (String) description.getValue();
    }
    
    /**
     * sets the description
     *
     * @param description the description
     */
    public void setDescription(String description) {
        
        if( null != description ) {
            StructuredDocument newdoc =
            StructuredDocumentFactory.newStructuredDocument(
            MimeMediaType.XMLUTF8, "Desc", description );
            
            setDesc( newdoc );
        }
        else
            this.description = null;
    }
    
    /**
     * returns the description
     *
     * @since JXTA 1.0
     *
     * @return the description
     *
     */
    public StructuredDocument getDesc() {
        if ( null != description ) {
            StructuredDocument newDoc =
            StructuredDocumentUtils.copyAsDocument(description);
            
            return newDoc;
        } else
            return null;
    }
    
    /**
     * sets the description
     *
     * @since JXTA 1.0
     *
     * @param desc the description
     *
     */
    public void setDesc( Element desc ) {
        
        if( null != desc )
            this.description = StructuredDocumentUtils.copyAsDocument(desc);
        else
            this.description = null;
    }
    
    /**
     * returns the debugLevel
     *
     * @return String the debugLevel
     */
    public String getDebugLevel() {
        return debugLevel.trim();
    }
    
    /**
     * sets the debugLevel
     *
     * @param debugLevel the debugLevel
     **/
    public void setDebugLevel(String debugLevel) {
        this.debugLevel = debugLevel;
    }
    
    /**
     *  {@inheritDoc}
     **/
    protected boolean handleElement( Element raw ) {
        
        if ( super.handleElement( raw ) )
            return true;
        
        XMLElement elem = (XMLElement) raw;
        
        if (elem.getName().equals(PID_TAG)) {
            try {
                URI pID = new URI( elem.getTextValue() );
                setPeerID((PeerID) IDFactory.fromURI( pID ));
            } catch ( URISyntaxException badID ) {
                throw new IllegalArgumentException( "Bad PeerID ID in advertisement: " + elem.getTextValue() );
            } catch ( ClassCastException badID ) {
                throw new IllegalArgumentException( "Id is not a peer id: " + elem.getTextValue() );
            }
            return true;
        }
        
        if( elem.getName().equals(NAME_TAG)) {
            setName( elem.getTextValue() );
            return true;
        }
        
        if( elem.getName().equals(DESC_TAG)) {
            setDesc( elem );
            return true;
        }
        
        if ( DEBUG_TAG.equals(elem.getName()) ) {
            setDebugLevel( elem.getTextValue() );
            return true;
        }
        
        return false;
    }
    
    /**
     *  {@inheritDoc}
     **/
    public Document getDocument( MimeMediaType encodeAs ) {
        StructuredDocument adv = (StructuredDocument) super.getDocument( encodeAs );
        
        Element e;
        
        // peer ID is optional. (at least for the PlatformConfig it is)
        PeerID peerID = getPeerID();
        if( (null != peerID) && !ID.nullID.equals( peerID ) ) {
            e = adv.createElement( PID_TAG, peerID.toString() );
            adv.appendChild(e);
        }
        
        // name is optional
        if (getName() != null) {
            e = adv.createElement( NAME_TAG, getName());
            adv.appendChild(e);
        }
        
        // desc is optional
        StructuredDocument desc = getDesc();
        if( desc != null )  {
            StructuredDocumentUtils.copyElements(adv, adv, desc );
        }
        
        String debugLvl = getDebugLevel();
        if ( (debugLvl != null) && !DEBUG_TAG_DEFAULT.equals( debugLvl ) ) {
            e = adv.createElement( DEBUG_TAG, debugLvl );
            adv.appendChild(e);
        }
        
        super.addDocumentElements( adv );
        
        return adv;
    }
    
    /**
     *  {@inheritDoc}
     **/
    public String [] getIndexFields() {
        return fields;
    }
}
